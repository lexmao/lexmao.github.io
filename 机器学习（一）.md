#####机器学习（一）
***


		参考<<机器学习实战>> <<统计学习方法>>

#######机器学习的概念：
 
揭示无序信息后面的本质，把这些庞大的、无序的信息转为有用得信息。有用的信息，意味着<br>可以看到
信息的本质，可以做决策依据。

如果有已知数据X1,X2,X3,X4,X5...Xn，想知道因变因子Y随X1...Xn的变化本质和趋势。如果，有<br>
一个精准的数学模型，比如Y=aX1+bX2+cX3.....+U, 那么我们从X1...Xn就可以精准地获得Y的本质。<br>但是，很多时候，并不存在这样精准的数学模型，这个时候要获得Y的本质，就需要统计学来解决。<br>
机器学习就是在统计学的基础上，根据学习、探索X1,X2...，发现其规律，最终找到Y的本质及Y和<br>X1....Xn的关系。




**机器学习的主要任务就是分类**

根据一个程序员在互联网上的大量碎片信息，可以通过机器学习把他分类为优秀或一般的程序员；<br>
根据你在网络上听的音乐历史歌曲，可以通过机器学习把你分类到某一音乐爱好类别，然后推荐出<br>
你喜欢的音乐；<br>
根据你在网络上阅读的历史数据，可以通过机器学习把你分类到某一阅读偏爱类别，然后给你推荐<br>
你喜欢的文章;
......


机器学习，既然是学习，那么就必须有一个学习的过程：基于已知的数据作为算法的训练集，让计<br>
算机根据我们采用的某一个分类算法进行学习。

对于评判优秀程序员，假设从已知程序员信息上，我们看到有以下信息特征（数字表示分数）：

	信息名称        学校     学历       专业   经验（年）            目标变量
	Info1          8         7        9       3                   优秀
	Info2          6         8        8       5                   优秀
	Info3          5         5        4       3                   一般
	Info4          8         5        5       3                   良好


现在的问题是：我们获得了一个新来的程序员的特征信息如下，他属于哪个级别的程序员？

	信息名称        学校    学历   专业     经验（年）       目标变量
	Info5          2       3     9      8               ？？？？

 


 **机器学习的另外一个任务就是回归**


预测数值型数据，研究一个随机变量Y对另一个(X)或一组(X1，X2，…，Xk)变量的相依关系的统计<br>
分析方法。如下的例子：

	信息名称    户外广告(万)    电视广告(万)    网络视频广告(万)    广播(万)     销售(万)    
	Info1        20           30              90                 8         1200      
	Info1        10           40              60                 3         1000      
	Info1        5            50              100                0         1800      
	Info1        30           10              150                2         2000      
	Info1        50           100             20                 10        1600      
	....

问题：

*为了提高销售额，获得广告投放最大的ROI，应该采用什么样的广告投放策略？*



目标是解决以上2个问题。

***

第一个问题，是利用机器学习和算法解决一个归类问题。

首先要解决这些数据的特征是怎来的？比如有些专业是5分，有些专业是2分？这部分一种方式是靠经验<br>
和常识来处理；另外一种方式是收据所有‘优秀程序员’的数据，提取特征。<br>
这是另外一个重要的话题。目前，我们要解决的是已经知道这些特征值得情况下，需要对新来程序员进<br>
行分类。所以，假设这些特征的标准我们已经拥有。


解决问题的算法： *K-近邻算法*，通过测量每组特征值之间的距离来确定所属归类。<br>
一组特征值，就是一 个向量；所以，这里实质上是测试2个向量的距离，这可以用欧氏距离公式搞定：<br>

	比如2个特征变量：

 	d = sqrt( (x1-x2)^2+(y1-y2)^2 )

	3个特征变量：

	d = √( (x1-x2)^2+(y1-y2)^2+(z1-z2)^2 )　

	n个特征变量：

	d(A，B) =√ [ ∑( a[i] - b[i] )^2 ] (i = 1，2，…，n)
	
	
	a是需要归类的特征矩阵： a=[a1,a2,a3,a4...an]   
	
	
	b是机器学习的已经知道的特征矩阵(m*n)：b=[ [b1,b2,b3,b4....bn]
	                               [c1,c2,c3,c4....cn]
								    [d1,d2,d3,d4....dn]
								]
								
     现在分别用b中得每一行（每一组特征向量）和 a计算距离，计算的方式就是
     D1(b1,a) =  √ (b1-a)^2 +(b2-a)^2+(b3-a)^2
     D2(c1,a) =  √ (c1-a)^2 +(c2-a)^2+(c3-a)^2
     D3(d1,a) =  √ (d1-a)^2 +(d2-a)^2+(d3-a)^2
     
     ...
     Dn(X1,a)=...
     
     最后获得一个n*1 大小的矩阵 D = [ [D1]
 								   [D2]
                                  [D3]
                                  [D4]
                                  ....
                                  [Dm]
                                  ]
                                  
     然后按照D1,D2,D3...Dm的大小排序 D' =[[D2]      假设D2<D1<D3...<Dm
 								        [D1]
       							        [D3]
       							         ...
       							        [Dm]
       							        ]
       							   
     选取 最小的K个点，假设K=3,则：
     
               				D‘’ =[[D2]
								  [D1]
 								  [D3]]
 	
 	计算在D''中每个类比出现的频率，比如D2 是优秀，D1是优秀,D3的类别是一般
 	
 	频率最高的类别就是答案，优秀的频率是2,一般是1，良 是0
 	所以，结果是  '优秀'
     
     


有了以上理论基础，开始用python代码来解决具体上面的归类问题：



准备好原始已知道数据 developer.txt:

 	cat developer.txt 
	优秀，良好，一般 分别用3,2,1来表示
	每一列用空格分隔
	学校    学历   专业   经验（年）      目标变量
	8 7 9 3 3 
	6 8 8 5 2
	5 5 4 3 1 
	7 5 4 3 2 
	9 6 7 6 3                                                     
	6 8 6 8 3                                                      
	3 4 6 4 1                                                      
	7 5 5 4 2 


把该文件数据 导入程序（转化为矩阵和目标变量向量）

		#第一件事,导入已知数据
		#filename 数据源文件名
		#feature_len 特征变量的个数,本例子中为4个
		#返回包含特征的矩阵和目标变量向量

		def loadDataFromFile(filename,feature_len):
    		fr = open(filename)

    		dataLines =fr.readlines()
    		lineNumber = len(dataLines)
    		classLabelVector=[]

    		for line in dataLines:
        		if line.find('#') == 0 : #find '#'line
            		dataLines.remove(line)
    
    		lineNumber = len(dataLines)
    		classLabelVector=[]
    		dataMat=np.zeros((lineNumber,feature_len))

    		row_index=0
    		for line in dataLines:
        		line = line.strip()
        		listFromLine =line.split(' ')
        		dataMat[row_index,:]=listFromLine[0:feature_len]
        		classLabelVector.append((listFromLine[-1]))
        		row_index +=1
        

    		return dataMat,classLabelVector


		if __name__ == '__main__':

    		dataMat,labels=loadDataFromFile('developer.txt',4)

    		print(dataMat)
    		print(labels)



执行 python developer.py 返回
			
	[[ 8.  7.  9.  3.]
 	[ 6.  8.  8.  5.]
 	[ 5.  5.  4.  3.]
 	[ 7.  5.  4.  3.]
 	[ 9.  6.  7.  6.]
 	[ 6.  8.  6.  8.]
 	[ 3.  4.  6.  4.]
 	[ 7.  5.  5.  4.]]

	['3', '2', '1', '2', '3', '3', '1', '2']



	#开始计算距离
	#首先要传入要求解的目标向量inX
	#dataSet  是上导入的竞争和目标向量,k是进行比较的条数

	def classify0(inX, dataSet, labels, k):
    	row_size = dataSet.shape[0] #获得矩阵中得行数
    	#构造一个矩阵,每一行的向量是inX,一共有row_size行
    	#目的是要实施两个矩阵运算行列个数一致

    	tempMat =np.tile(inX,(row_size,1))


    	#欧氏距离公式 d(A，B) =√ [ ∑( a[i] - b[i] )^2 ] (i = 1，2，…，n)

    	diffMat = tempMat-dataSet #矩阵运算,相减
    	sqDiffMat = diffMat**2
    	#求和 axis=1,计算每一行的和,axis=0按列计算
    	sqDistances = sqDiffMat.sum(axis=1)

    	#开方运算
    	distances = sqDistances**0.5

    	#排序
    	sortedDistIndicies = distances.argsort()
    	classCount={}

        #计算每个类别出现的频率
    	for i in range(k):
        	votellabel = labels[sortedDistIndicies[i]]
        	classCount[votellabel] = classCount.get(votellabel,0) + 1

		#根据类别频率排序
    	sortedClassCount = sorted(classCount.iteritems(),
        	key=operator.itemgetter(1), reverse=True)

		#返回频率最大的特征
    	return sortedClassCount[0][0]

	
	if __name__ == '__main__':

    	level_list=['未知','一般','良好','优秀']
    	dataMat,labels=loadDataFromFile('developer.txt',4)
    	normDataMat,ranges,min =autoNorm(dataMat)


    	inX=np.array([2,3,9,8])
    	inX =(inX-min)/ranges

    	k=3

    	who =classify0(inX, normDataMat, labels, k)

    	outs='该程序员属于*%s*类别'%level_list[int(who)]
    	print(outs)



	# python developer.py 
	该程序员属于*一般*类别

到此为止，解决了第一个问题，关于程序员归类的问题。

[demo代码](https://github.com/lexmao/blog_source/blob/master/developer_kNN.py)
















